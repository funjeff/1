//code for main
	
	MOV X0, #100 //address 100
	MOV X1, #200 // 25 elements 8 bytes each
	
	B.fill
	
	MOV X0, #100
	MOV X1, #200

	B.sort
	
	B.end

//code for insertion sort 

	sort: ADDI X10, XZR, #1 //i = 1
	MOV X12, X0 // x12 = start of araay
	SUBI X11, X1, #1 // X11 = length -1
	MOV X1, X10 // arg2  = i
	MOV X2, X11 // arg3 = length -1
	MOV X15, X30 // saves link register
	sortLoop:
	B.insert //calls function
	MOV X0, X12 // arg1 = start of array
	ADDI X10, X10, #1 // i = i + 1
	MOV X1, X10 // arg2 = i
	MOV X2, X11 // arg3 = length - 1 
	CMP X10, X11 // compartes (apparently doesen't work with the emulator)
	BLT.sortLoop // goes back
	MOV X30, X15 // resets link register
	BR BL // goes back



// code for insert sorted pos
	 
	 insert: ADD X3, X0, X1 //X3 = end of array
	 MOV X15, X30 //saves link register
	 MOV X9, X2 // saves end of array to X9
	 MOV X10, X0 // saves Arg1 to X10
	 LDUR X1, [X3, #0] //Arg2 = *(end of array)
	 MOV X12, X1 // Saves X1
	 B.find // calls find
	 MOV X11, X0 //saves result from find to X11
	Â MOV X1, X0 // Arg1 = result from find
	 MOV X0, X10 // Arg0  = beginning of array
	 MOV X2, X9 // Arg2 = final Index
	 B.shift // calls function
	 ADD X0, X10, X11 //X0 = array start + result of find
	 STUR X12, [X0, #0] // stores passed argument into correct slot
	 MOV X30, X15 // resets link register
	 BR BL //returns

// code for find sorted pos
	find: MOV X4, XZR // i = 0
	fillLoop: 
	LSL X6, X4, #3 // X6 = i * 8 
	ADD X5, X0, X6 // X5 gets the indesx of the ith elemnt of the array
	LDUR X5, [X5, #0] // X5 gets the element value from the array
	CMP X5, X1 // compares (again gonna have to be changed)
	BLT.endLoop //breaks if need be
	ADDI X4, X4, #1 // i = i + 1
	
	CMP X4, X2 //compares (needs to be changes AGAIN!)
	BLT.fillLoop //loops
	
	endLoop: MOV X0, X4 //sets up return value
	BR BL

//code for shift right
	shift: ADD X3, X0, X1 //X3 = element at "pos"
	LDUR X3, [X3, #0] // X3 now gets the value of element at "pos"
	shiftLoop: ADDI X1, X1, #8 // pos = pos + 8
	
	MOV X4, X3 //X4 gets X3
	ADD X3, X0, X1// X3 now points to address at new X1
	LDUR X5, [X3, #0] //store the value at the new X3
	STUR X4, [X3, #0] // old X3 gets put in the slot of new X3
	MOV X3, X5 // X3 gets the value that used to be at the X3 pos
	
	CMP X1, X2 //compare needs to be changed again
	BNE.shiftLoop // loops if the index inse't at the the end
	BR BL // goes back


//code for "fill" function
	fill: MOV X2, X0 // X2 is now start of array
	ADD X1, X0, X1 // X1 is end of array
	fillLoop:
	//calculates length - i
	SUB X4, X1, X0 // X4 is end of array
	SUB X5, X2, X0 // X5 amount of the array incremented
	SUB X4, X4, X5 // X4 is the length - 1
	
	STUR X4, [X2, #0] // store the value of length - 1 to the array
	ADDI X2, #8 //i = i + 1
	
	CMP X2, X1
	BNE.fillLoop // if X2 is not the end of the array loop
	BR BL // go back
	
	end:
	
